/**
* Copyright (c) 2016-present, Facebook, Inc.
* All rights reserved.
*
* This source code is licensed under the BSD-style license found in the
* LICENSE_render file in the root directory of this subproject. An additional grant
* of patent rights can be found in the PATENTS file in the same directory.
*/

/*此文件生成虚拟的camera视角：把image切片渲染缝合成全景图，并计算出任意浏览的视角的左右眼图像（设计了一种数据结构（LazyNovelViewBuffer），描述了当前需要的新视角，然后一步求出结果）*/

#pragma once

#include <string>
#include <vector>

#include "OpticalFlowInterface.h"
#include "CvUtil.h"

namespace surround360 {
namespace optical_flow {

using namespace std;
using namespace cv;

// when rendering panoramas from slices of many novel views, there is lots of
// wasted computation. this is an idea for reducing that computation: build up
// a datastructure of just the pieces of the novel views we need, then do it
// all in 1 pass
    //当从各个视角切片合成全景图时，有很多低效的计算。现在采取一种方法，设计特殊的结构体，只记录我们所需的视角信息，并且完成计算
struct LazyNovelViewBuffer {
  int width, height;
  // warpL[u][v] = (x, y, t). in the final panorama image at pixel coord u, v
  // we will take a piece of the novel view image at x, y, and time shift t.
    //不清楚
  vector<vector<Point3f>> warpL;
  vector<vector<Point3f>> warpR;

  LazyNovelViewBuffer(int width, int height) {//包含了渲染一块立体全景图所需的所有数据
    this->width = width;
    this->height = height;
    warpL = vector<vector<Point3f>>(width, vector<Point3f>(height));
    warpR = vector<vector<Point3f>>(width, vector<Point3f>(height));
  }
};

struct NovelViewUtil {
  // given an image, a flow vector field of the same size, generate a new image by
  // applying the flow to the input, scaled by t.
    //输入一副图像、等尺寸的光流信息，生成新的图像，实现基础光流拼接
  static Mat generateNovelViewSimpleCvRemap(
    const Mat& srcImage,
    const Mat& flow,
    const double t);

  // for a left/right image pair, we compute flow from left to right, and right to left.
  // generate novel view by warping the left image to be like the right, and the right
  // image to be like the left, then blend the two warped results. in cases where ghosting
  // would occur (because the left and right warped images are not similar in color at
  // some pixels), a ghosting resolution heuristic is applied which prefers the pixel
  // color with the larger magnitude flow (which corresponds to the closer object in cases
  // of occlusion). to avoid seams, the logic for determining if/how much deghosting to
  // apply is not binary; instead it uses softmaxes to smoothly transition between normal
  // blending and flow-magnitude weighted blending.
    //左右眼图像，计算从左至右和从右至左的光流。
    //修正左边的图像，使之像右边；再修正右边的图像，使之像左边，
    //然后协调这两幅结果图像。
    //因为两幅图在某处的像素的颜色并不一样，于是导致重影，一种启发式的重影的解决方法就是采用，此处光度（饱和度）高的像素。这对近处的物体效果好。
    //为了避免上述方法导致的缝合线,判断是否或者如何如重影不是非此即彼的，使用柔性最大函数来过度普通的图像混合和光度最大的混合方法。
    //合成新视角
  static Mat combineNovelViews(
    const Mat& imageL,
    const float blendL,
    const Mat& imageR,
    const float blendR,
    const Mat& flowLtoR,
    const Mat& flowRtoL);

  // similar to combineNovelViews, but imageL and imageR are expected to be generated
  // by rendering a LazyNovelViewBuffer, which means their alpha channel encodes the
  // amount of blending/warping. uses similar flow based deghosting.
    //合成新视角也是如此，不过左右眼图像先要生成LazyNovelViewBuffer，这意味着他们的alpha（饱和度）通道将要记录图像混合的数量，和上述去重影的方法差不多
  static Mat combineLazyViews(
    const Mat& imageL,
    const Mat& imageR,
    const Mat& flowMagL,
    const Mat& flowMagR);
};

// the is an abstract base class for novel view generators
    //抽象类 “新视角生成器”
class NovelViewGenerator {
public:
  virtual ~NovelViewGenerator() {};

  // a NovelViewGenerator may be asked to generate many novel views, but it
  // only needs to do somethings once (like computing disparity). this will be
  // called before anything else.
    //新视角生成器可能有很多工作要做，此类把只要做一次的工作提取出来，优化整体工作效率
  virtual void prepare(
    const Mat& colorImageL,
    const Mat& colorImageR,
    const Mat& prevFlowLtoR,
    const Mat& prevFlowRtoL,
    const Mat& prevColorImageL,
    const Mat& prevColorImageR) = 0;

  // simplified version of prepare which doesn't require previous frame data,
  // to be used when we don't care about temporal regularization.
    //简化没有前一帧的情况下的一些准备工作，这时候“临时规则”会被改变，这个在PixFlow.h中也有出现。
  void prepare(const Mat& colorImageL, const Mat& colorImageR) {
    Mat prevFlowLtoR, prevFlowRtoL, prevColorImageL, prevColorImageR;
    prepare(
      colorImageL,
      colorImageR,
      prevFlowLtoR,
      prevFlowRtoL,
      prevColorImageL,
      prevColorImageR);
  }
  // generate a novel that synthesizes a camera between colorImageL and colorImageR.
  // when shiftFromL = 0, this will be ~equal to the original colorImageL, and when
  // shiftFromL = 1, the novel view is at colorImageR. results are generated by warping
  // both the left and right input images and combining the two warped images- the main
  // result is in outNovelViewMerged. outNovelViewFromL/R are for debugging/visualization.
    //生成一个新的图像，介于左图和右图之间（coslorImageL and colorImageR），如果shiftFromL=0，那么就和左图原图一致，如果shiftFromL=1，那么就是和右图原图一致。
    //结果这样生成：1、弯曲左右两图2、结合两幅弯曲的图片。3、结果存储于outNovelViewMerged
    //outNovelViewFromL/R 用于可视化的debug
  virtual void generateNovelView(
    const double shiftFromL,
    Mat& outNovelViewMerged,
    Mat& outNovelViewFromL,
    Mat& outNovelViewFromR) = 0;

  // returns a pair where the first item is the novel view image
  // (with channel 3 encoding novel view shift value), and the second item is
  // a matrix of flow magnitudes (which are used later in deghosting).
    //返回两个数据，第一个是3个通道转换的新视角图像，第二个是光流（光饱和度）的矩阵，之后的去重影会用到
  virtual pair<Mat, Mat> renderLazyNovelView(
    const int width,
    const int height,
    const vector<vector<Point3f>>& novelViewWarpBuffer,
    const Mat& srcImage,
    const Mat& opticalFlow,
    const bool invertT) = 0;

  // a LazyNovelViewBuffer contains all the data needed to render a chunk of a
  // stereo panorama. implementations should return a left/right eye image pair.
  // left and right image indices are passed in so we can get samples of matched
  // pixels for the purpose of color calibration.
    //LazyNovelViewBuffer 包含了渲染一块立体全景图所需的所有数据。本函数返回一对图像，左右图像的索引
    //已经“上交”，所以我们可以在色彩渲染时获定位像素
  virtual pair<Mat, Mat> combineLazyNovelViews(
    const LazyNovelViewBuffer& lazyBuffer) = 0;

  // for debugging
  virtual Mat getFlowLtoR() { return Mat(); }
  virtual Mat getFlowRtoL() { return Mat(); }
};

// this is a base class for novel view generators that work by reduction to optical flow.
// it handles lazy generation fo the novel views, given flow.
    //通过化简光流工作，lazy算法
class NovelViewGeneratorLazyFlow : public NovelViewGenerator {
public:
  Mat imageL, imageR;
  Mat flowLtoR, flowRtoL;

  ~NovelViewGeneratorLazyFlow() {}

//生成新的视角图像
  void generateNovelView(
    const double shiftFromL,
    Mat& outNovelViewMerged,
    Mat& outNovelViewFromL,
    Mat& outNovelViewFromR);

  pair<Mat, Mat> renderLazyNovelView(
    const int width,
    const int height,
    const vector<vector<Point3f>>& novelViewWarpBuffer,
    const Mat& srcImage,
    const Mat& opticalFlow,
    const bool invertT);

//生成左右眼合成的新图像
  pair<Mat, Mat> combineLazyNovelViews(const LazyNovelViewBuffer& lazyBuffer);

  Mat getFlowLtoR() { return flowLtoR; }
  Mat getFlowRtoL() { return flowRtoL; }
};

// the name "asymmetric" here refers to the idea that we compute an optical flow from
// left image to right image, and from right to left, and these flows may not necessarily
// be symmetric. however this is convenient because it is general reduction to optical
// flow. we might try other ideas, e.g. generate both flows simultaneously in a way that
// avoids redundant calculations. that would be a different subclass of
// NovelViewGeneratorLazyFlow.
    //左右扫描和右左扫描得到的光流是不严格对称的，但是这方便了简化光流。
    //FB也可能用其他方法来简化算法,比如同时生成左右，右左，那么下面这个类就会改变。
class NovelViewGeneratorAsymmetricFlow : public NovelViewGeneratorLazyFlow {
public:
  string flowAlgName;

//生成新的视角图像
  NovelViewGeneratorAsymmetricFlow(const string flowAlgName) : flowAlgName(flowAlgName) {}

  ~NovelViewGeneratorAsymmetricFlow() {}

//根据flowAlgName计算光流，左右，右左
  void prepare(
    const Mat& colorImageL,
    const Mat& colorImageR,
    const Mat& prevFlowLtoR,
    const Mat& prevFlowRtoL,
    const Mat& prevColorImageL,
    const Mat& prevColorImageR);
};

} // namespace reprojection
} // namespace surround360
